#!/bin/rc
# 
# Multipipe Regression
#

echo '== Multipipe Regression =='

#
# Parameters
#
MPIPELOG=mpipefs.log
TESTDIR=.test
DEBUG_LEVEL=0

#
# Cleanup Previous Instances
#
fn cleanup {
	echo Cleaning up previous runs...
	unmount /n/mpipetest > /dev/null >[2] /dev/null
	rm -f /srv/mpipe
	#kill mpipefs | rc
}

#
# Startup mpipefs (maybe with debug evel specified by $1)
#
fn startup {
	echo Starting mpipefs....
	if(~ $#* 0) {
		mpipefs >[2] $MPIPELOG 
	}
	if not {
		mpipefs -D -v $1 >[2] $MPIPELOG 	# CHATTY
		DEBUG_LEVEL=$1
	}
}

#
# Setup a ramfs
#
fn testdir {
	mkdir -p $TESTDIR
}

#
# The test number names are generated and cached for later use.
#
TESTNUM=( 1 )

#
# Create a number of tests
#
fn create_tests {
	# 
	TESTNUM=`{awk 'BEGIN     {
               for (i = 1; i <= '$1'; i++) printf "%d ", i
               exit }'}

	#`# create empty test files 
	for(i in $TESTNUM) {
	    echo > $TESTDIR/test$i
	}
}

#
# Compare the output
#
fn cmp_tests {
	# 
	TESTNUM=`{awk 'BEGIN     {
               for (i = 1; i <= '$1'; i++) printf "%d ", i
               exit }'}

	#`# verify results
	for(i in $TESTNUM) {
	    if(! cmp -s $TESTDIR/test $TESTDIR/test$i) {
	        echo
		echo '	'FAILED: test$i not equal to test
		exit 'cmp_tests: test$i failed for: ' $2
	    }
	}
}

#
# Check to make sure that the files are ready to read and not just
# opened or hung.
#
APID=() # keep a list of child PID's
fn check_ready {
	if(! ~ $DEBUG_LEVEL 0) {
		echo
		echo '    Checking readyness'
	}

	# FIXME: should we terminate after some number of tries, or
	# just keep spinning...
	DONE=0
	while (~ $DONE 0) {
		DONE=1
		for(i in $APID) {
	    		STATE=`{cat /proc/$i/status | sed 's%cat[ ]*[^ ]*[ ]*%%
				s%  *.* (.*)%%'}
	    		#` turn off the code coloring snafu

	    		# check if it is not ready to read
			if(! ~ $STATE 'Pread') {
				if(! ~ $DEBUG_LEVEL 0) 
	    				echo '        ' $i $STATE
				DONE=0
			}
		}
       	}
}

#
# Naming pipe test
#

fn named {
	echo -n Testing name parameter...

	mount /srv/mpipe /n/mpipetest test
	if(! test -e /n/mpipetest/test) {
		echo FAILED!
		exit 'named: test failed'
	}

	echo Success!	
	# cleanup
	unmount /n/mpipetest
}


#
# Simple Pipe Test
#

fn simplepipe {
	echo -n Testing simple pipe operation...

	# initialize files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 1

	mount /srv/mpipe /n/mpipetest
	cat $TESTDIR/test > /n/mpipetest/data &
	cat /n/mpipetest/data > $TESTDIR/test1

	# verify results
	cmp_tests 1 'simplepipe'

	echo Success!
	# cleanup
	rm -rf $TESTDIR/*
}

# TODO: will this really happen deterministicly?
fn multipipe {
	echo -n Testing multipipe messages...

	# initialize files
	mount /srv/mpipe /n/mpipetest
	# FIXME: abstract?
	cat /n/mpipetest/data > $TESTDIR/test1 &
	cat /n/mpipetest/data > $TESTDIR/test2 &
	#sleep 10 # poor man's synchornization
	mp-writer -n 2 -s 8192 /n/mpipetest/data	

	# verify results
	# FIXME: abstract?
	if(! cmp -s $TESTDIR/test2 $TESTDIR/test1) {
		echo FAILED: test2 not equal to test1
		exit 'multipipe: test1 failed'
	}

	echo Success!
	# cleanup
	rm -rf $TESTDIR/*
}

fn enum {
	echo -n Testing enumerated messages...

	# initialize files

	mount /srv/mpipe /n/mpipetest '-e 2'
	cat /n/mpipetest/data > $TESTDIR/test1 &
	cat /n/mpipetest/data > $TESTDIR/test2 &
	#sleep 5 # poor man's synchornization
	mp-writer -e 1 -n 5 -s 8192 /n/mpipetest/data	

	#sleep 5 # poor man's synchornization
	if(test -s $TESTDIR/test1) {
		if(test -s $TESTDIR/test2) {
			echo FAILED: both files have data
			exit 'enum: both files have data'
		}
	}

	echo Success!
	# cleanup
	rm -rf $TESTDIR/*
}

# TODO: 8192 is not long enough, but anything above 64k breaks
fn longmsg {
	echo -n Testing long messages...

	# initialize files
	rm -rf $TESTDIR/*

	mount /srv/mpipe /n/mpipetest
	# FIXME: abstract?
	cat /n/mpipetest/data > $TESTDIR/test1 &
	cat /n/mpipetest/data > $TESTDIR/test2 &
	#sleep 5 # poor man's synchornization
	mp-writer -e 1 -n 1 -s 131072 /n/mpipetest/data	

	# FIXME: abstract?
	if(test -s $TESTDIR/test1) {
		if(test -s $TESTDIR/test2) {
			echo FAILED: both files have data
			exit 'longmsg: both files have data'
		}
	}

	echo Success!
	# cleanup
	rm -rf $TESTDIR/*
}

# Broadcast test
#
fn bcast {
	echo -n Testing with broadcast...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 2

	# accomplish the test
	mount /srv/mpipe /n/mpipetest -b
	# FIXME: abstract?
	cat /n/mpipetest/data > $TESTDIR/test1 &
	cat /n/mpipetest/data > $TESTDIR/test2 &	
	#sleep 5	# poor mans synchronization
	cat $TESTDIR/test > /n/mpipetest/data
	unmount /n/mpipetest
	
	# verify results
	cmp_tests 2 'bcast'

	echo Success!

	# cleanup
	rm -rf $TESTDIR/*
}

#
# splicefrom test
#
fn splicefrom {
	echo -n Testing splicefrom...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 1

	# accomplish the test
	mount /srv/mpipe /n/mpipetest
	cat /n/mpipetest/data > $TESTDIR/test1 &
	mp-writer -i $TESTDIR/test /n/mpipetest/data
	
	unmount /n/mpipetest

	#sleep 5
	
	# verify results
	cmp_tests 1
	
	echo Success!

	# cleanup
	rm -rf $TESTDIR/*
}

#
# splicefrom broadcast test
#
fn splicefrombcast {
	echo -n Testing splicefrom with broadcast ...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test

	# create empty test files
	create_tests 20


	# accomplish the test
	mount /srv/mpipe /n/mpipetest -b

	# spawn a number of threads which copy the mpipe data the
	# tests.  It waits for stuff to be written to
	# /n/mpipetest/data
	for(i in $TESTNUM) {
	    cat /n/mpipetest/data > $TESTDIR/test$i &
	    APID=( $APID $apid )
	}

	# make sure that everything is ready
	check_ready # poor mans synchronization

	mp-writer -i $TESTDIR/test /n/mpipetest/data
	
	# FIXME: check_ready # verify that the state of the write is done
	wait

	# verify results
	cmp_tests 20

	echo Success!
	unmount /n/mpipetest

	# cleanup
	rm -rf $TESTDIR/*
}

#
# spliceto test
#
fn spliceto {
	echo -n Testing spliceto...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 1

	# accomplish the test
	mount /srv/mpipe /n/mpipetest
	mp-writer -o $TESTDIR/test1 /n/mpipetest/data

	cat $TESTDIR/test > /n/mpipetest/data

	unmount /n/mpipetest
	
	# verify results
	cmp_tests 1

	echo Success!

	# cleanup
	rm -rf $TESTDIR/*
}

#
# splice to chain to tests problem
# experienced using multinode gangfs
#

fn splicetochain {
	echo -n Testing spliceto chains...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 1

	# accomplish the test
	# stage0 and stage1 feeds stage2 which feeds stage3
	mount /srv/mpipe /n/stage0 s0
	mount /srv/mpipe /n/stage1 s1
	mount /srv/mpipe /n/stage2 s2
	mount /srv/mpipe /n/stage3 s3
	mp-writer -o /n/stage2/s2 /n/stage0/s0
	mp-writer -o /n/stage2/s2 /n/stage1/s1
	mp-writer -o /n/stage3/s3 /n/stage2/s2
	mp-writer -o $TESTDIR/test1 /n/stage3/s3
	echo one > /n/stage0/s0 &
	echo two > /n/stage1/s1 &
	
	#sleep 1
	
	unmount /n/stage0
	unmount /n/stage1
	unmount /n/stage2
	unmount /n/stage3
	
	# verify results
	echo one > $TESTDIR/test2
	echo two >> $TESTDIR/test2
	if(! cmp -s $TESTDIR/test2 $TESTDIR/test1) {
		echo FAILED: test1 not equal to test2
		exit 'splicetochain: failed'
	}
	
	echo Success!

	# cleanup
	rm -rf $TESTDIR/*
}

#
# Broadcast spliceto test
#
fn splicetobcast {
	echo -n Testing spliceto with broadcast...

	# initialize test files
	echo Hello Squidboy > $TESTDIR/test
	create_tests 2

	# accomplish the test
	mount /srv/mpipe /n/mpipetest -b
	mp-writer -o $TESTDIR/test1 /n/mpipetest/data
	mp-writer -o $TESTDIR/test2 /n/mpipetest/data
	#sleep 5	# poor mans synchronization
	cat $TESTDIR/test > /n/mpipetest/data
	unmount /n/mpipetest
	
	# verify results
	cmp_tests 2

	echo Success!

	# cleanup
	rm -rf $TESTDIR/*
}

# Setup
cleanup
startup $*
testdir

# Tests
named
simplepipe
#multipipe #<--- FAILS sometimes due to non-determinsm
longmsg
enum 
bcast
splicefrom
spliceto
splicetobcast
splicefrombcast
splicetochain

# Cleanup
rm -f $TESTDIR
cleanup

