#!/boot/rc -m /boot/rcmain
#flag x +

/boot/echo New Model Boot Script

cputype=power
objtype=$cputype
service=cpu
authid=glenda
rootdir=/root
rootspec=''
rootsrv=boot

beetroot=bgp.rr
#authentication='nvram=/boot/adm/nvram auth/factotum -sfactotum -S'	# -a ...
authentication=''
fsaddr=''
mode=''

#
# Post the read-only filesystem in #s/$beetroot
# and mount it on /boot so the commands in /boot/$cputype/bin
# are available to create the namespace (namespaces like to
# mount #s/boot on / and that should not be the read-only
# filesystem).
# Must set hostowner to be that of the owner of the nvram file
# before paqfs starts otherwise factotum will not be able to
# open it.
#
/boot/echo -n sys > '#c/hostowner'
/boot/paqfs -p -S $beetroot -m /boot -q /boot/$beetroot
cd /boot/$cputype/bin
bind '#c' /dev
bind -b '#æ' /dev
bind '#d' /fd
bind -c '#ec' /env
bind -cb '#e' /env
bind '#p' /proc
bind -c '#s' /srv

#
# Configure the networks.
#
# what are we? 
# figure out what kind of node we are and what the tree ip address is
bind -a '#:' /dev
bind -a '#P' /dev
bind -a '#I' /net

xyzip=(`{cat /dev/xyzip})
if (~ $xyzip(1) '255.255.255'){
	treeip=$xyzip(4)
	cpunode=0
	bind -a '#l0' /net
}
if not {
	treeip=$xyzip(1)
	cpunode=1
	#bind -a '#!' /dev
	bind -a '#∞' /dev
}

#
# I/O node has Ethernet on the outside.
# Everyone has Tree on the inside, loopback.
#
ip=(`{cat /dev/ioip})
if(~ $#ip 4 && ! ~ $ip(1) '0.0.0.0'){
	i=`{cat /net/ipifc/clone}
	echo bind gbe /net/ether0 > /net/ipifc/$i/ctl
	echo add $ip(1) $ip(2) $ip(3) > /net/ipifc/$i/ctl
	echo add 0 0 $ip(4) >>/net/iproute
	echo Ether: I am $ip(1)^, default route $ip(4)
}

#
# Tree
#
i=`{cat /net/ipifc/clone}
echo bind tree /dev/vc1 > /net/ipifc/$i/ctl
echo add 11.$treeip $xyzip(2) 11.$xyzip(3) > /net/ipifc/$i/ctl
echo add 12.$treeip $xyzip(2) 12.$xyzip(3) > /net/ipifc/$i/ctl
echo Tree: I am '1[12]'.$treeip^, pset I/O node 11.$xyzip(4)

i=`{cat /net/ipifc/clone}
echo bind loopback /dev/null > /net/ipifc/$i/ctl
echo add 127.0.0.1 255.0.0.0 127.0.0.0 > /net/ipifc/$i/ctl

#
# Torus
#
if(~ $cpunode '1'){
	i=`{cat /net/ipifc/clone}
	echo bind torus /dev/torus > /net/ipifc/$i/ctl
	echo add 10.$xyzip(1) $xyzip(2) 10.$xyzip(3) > /net/ipifc/$i/ctl
}
#
# Set up authentication if necessary.
# Factotum has to be allowed to mount on /mnt here because
# auth_proxy (called by mount) will look for it there.
# Normally, factotum will set '#c/hostowner'; if not, do it
# by hand.
#
if(! ~ $authentication '')
	eval `{echo $authentication}
if(~ `{cat '#c/hostowner'} sys)
	echo -n $authid > '#c/hostowner'

if(! test -d $rootdir/$rootspec/$cputype){
	rootdir=/boot
	rootspec=''
	rootsrv=$beetroot
}

bind -c $rootdir/$rootspec $rootdir
rootsrv='#s/'$rootsrv
echo root is on $rootdir, root is served from $rootsrv

#
# Finish the namespace setup.
#
bind -a $rootdir /
bind -b -c $rootdir/mnt /mnt
bind $rootdir/$cputype/bin /bin
bind -a $rootdir/rc/bin /bin
cd /

#
# Finish environment setup and start services.
#
if(~ $cpunode '1'){
	sysname=cpu-$treeip
}
if not {
	sysname=io-$ip(1)
}
prompt=($sysname'# ' '	') 

#
# start CIOD services
#
if(~ $cpunode '0'){
	# wait for ethernet to come up
	echo Waiting for turbines to come up to speed
	sleep 30
	
	aux/listen -i -t /bin/service.bgp tcp
	
	# do we only want to send this from one IO node?
	if (~$cpunode '0') {
		echo Initiating Handshake
		echo 0x01 0x1e 0x0 0 0 0 > /dev/ras
	}
	
	# wait for miniciod to do its thing, need better sync	
	sleep 5
	times=0
	while(! ~ $#times 5 && test ! -e '/env/MODE') {
		echo -n '.'
		times=($times 1)
		sleep 5
	}
}

#
# New FS Backmount Model
#
if(test -e '/env/MODE') {
	echo Mode detected
	mode=(`{cat /env/MODE})
	if(test -e '/env/BRASIL_ADDR')
		fsaddr=(`{cat /env/BRASIL_ADDR})

	ndb/cs

	if(~ $cpunode '0'){
		# wait for ethernet to come up
		echo fsaddr $fsaddr
		echo Atomic batteries to power

		times=0
		while(! ~ $#times 10 && ! ~ $fsaddr '' && ! eval srv -q -c -m $fsaddr frontend /n/frontend) {
			echo -n '.'
			times=($times 1)
			sleep 5
		}
		echo done.
	}

	if(test -e '/env/HOME') {
		fshome=(`{cat /env/HOME})
		bind /n/frontend^$fshome /n/home
	}
	
	if(test -e '/env/PLAN9_ROOT') {
		plan9root=(`{cat /env/PLAN9_ROOT})
		bind /n/frontend^$plan9root /n/root
	}
}
if not {
	echo No mode detected
}

if(~ $cpunode '1'){
	# wait at least 40 before proceeding to let I/O Node Setup
	echo Waiting for turbines to come up to speed
	sleep 40	
	echo would have mounted here!
	fsaddr='tcp!11.' ^ $xyzip(4) ^ '!564'
	times=0
	while(! ~ $#times 12 && ! ~ $fsaddr '' && ! eval srv -q -c -m $fsaddr ionode /n/io) {
		echo -n '.'
		times=($times 1)
		sleep 5
	}
		
#	Assuming things worked out
	bind -c /n/io/n/home /n/home
	bind -c /n/io/n/frontend /n/frontend
	bind -c /n/io/n/root /n/root
	bind -a /n/io/env /env
	mode=(`{cat /env/MODE})
	
	echo done.
}	

#ramfs so we can copy binaries in
ramfs /tmp

# execute user profile
if(test -e '/n/home/lib/profile') {
		. /n/home/lib/profile
}

# TODO: evaluate whether to do this in profile or based on option
echo starting services
bind /boot/rc/bin/service /bin/service

if(test -d /mnt/factotum)
	aux/listen -i -q tcp
if not
	aux/listen -i -t /bin/service tcp
	
fn runit {
	# this can probably be done a better way, but
	#   first check if its in our namespace, then check if its in the frontend ns
	if(test -e $job_home)
		cd $job_home
	if not
		cd /n/frontend^$job_home
	
	if(test -e $1)
		eval $task
	if not
		cmd = /n/frontend^$1
		shift 1
		args = $*
		eval ($cmd $args)
}

# TODO: send output someplace nice
if(~ $cpunode '1'){
	if(~ $mode nompirun) {
		if(test -e '/env/job_homedir') 
			job_home=(`{cat /env/job_homedir})
		if(test -e '/env/job_args') 
			job_args=(`{cat /env/job_args})	
	
		task=`{echo $job_args}
		runit $task
		
		echo done
		# TODO: perhaps send a RAS message signaling job completetion?
		# and then spin - exiting here seems to be bad		
	}
}
	
# what does this actually do?	
while(echo Hello Squidboy)
	. -i '#d/0'
