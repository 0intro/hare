#!/boot/rc -m /boot/rcmain
#flag x +

if(test -f '#P'/script)
	. '#P'/script

/boot/echo In default boot script

cputype=power
objtype=$cputype
service=cpu
authid=glenda
rootdir=/root
rootspec=''
rootsrv=boot

beetroot=bgp.rr
#authentication='nvram=/boot/adm/nvram auth/factotum -sfactotum -S'	# -a ...
authentication=''
fsaddr=''

#
# Post the read-only filesystem in #s/$beetroot
# and mount it on /boot so the commands in /boot/$cputype/bin
# are available to create the namespace (namespaces like to
# mount #s/boot on / and that should not be the read-only
# filesystem).
# Must set hostowner to be that of the owner of the nvram file
# before paqfs starts otherwise factotum will not be able to
# open it.
#
/boot/echo -n sys > '#c/hostowner'
/boot/paqfs -p -S $beetroot -m /boot -q /boot/$beetroot
cd /boot/$cputype/bin
bind '#c' /dev
bind -b '#æ' /dev
bind '#d' /fd
bind -c '#ec' /env
bind -cb '#e' /env
bind '#p' /proc
bind -c '#s' /srv

#
# Configure the networks.
#
# what are we? 
# figure out what kind of node we are and what the tree ip address is
bind -a '#:' /dev
bind -a '#P' /dev
bind -a '#I' /net

xyzip=(`{cat /dev/xyzip})
if (~ $xyzip(1) '255.255.255'){
	treeip=$xyzip(4)
	cpunode=0
	bind -a '#l0' /net
}
if not {
	treeip=$xyzip(1)
	cpunode=1
	#bind -a '#!' /dev
	bind -a '#∞' /dev
}

#
# I/O node has Ethernet on the outside.
# Everyone has Tree on the inside, loopback.
#
ip=(`{cat /dev/ioip})
if(~ $#ip 4 && ! ~ $ip(1) '0.0.0.0'){
	i=`{cat /net/ipifc/clone}
	echo bind gbe /net/ether0 > /net/ipifc/$i/ctl
	echo add $ip(1) $ip(2) $ip(3) > /net/ipifc/$i/ctl
	echo add 0 0 $ip(4) >>/net/iproute
	echo Ether: I am $ip(1)^, default route $ip(4)
}

#
# Tree
#
i=`{cat /net/ipifc/clone}
echo bind tree /dev/vc1 > /net/ipifc/$i/ctl
echo add 11.$treeip $xyzip(2) 11.$xyzip(3) > /net/ipifc/$i/ctl
echo add 12.$treeip $xyzip(2) 12.$xyzip(3) > /net/ipifc/$i/ctl
echo Tree: I am '1[12]'.$treeip^, pset I/O node 11.$xyzip(4)

i=`{cat /net/ipifc/clone}
echo bind loopback /dev/null > /net/ipifc/$i/ctl
echo add 127.0.0.1 255.0.0.0 127.0.0.0 > /net/ipifc/$i/ctl

#
# Torus
#
if(~ $cpunode '1'){
	i=`{cat /net/ipifc/clone}
	echo bind torus /dev/torus > /net/ipifc/$i/ctl
	echo add 10.$xyzip(1) $xyzip(2) 10.$xyzip(3) > /net/ipifc/$i/ctl
}
#
# Set up authentication if necessary.
# Factotum has to be allowed to mount on /mnt here because
# auth_proxy (called by mount) will look for it there.
# Normally, factotum will set '#c/hostowner'; if not, do it
# by hand.
#
if(! ~ $authentication '')
	eval `{echo $authentication}
if(~ `{cat '#c/hostowner'} sys)
	echo -n $authid > '#c/hostowner'

#
# Attach to the remote filesystem and mount it.
# If this fails, set $root(dir|srv) and continue,
# there's enough in the read-only filesystem to run
# listen and telnet; at least cat /dev/kmesg might
# then give a clue as to the problem.
# Must check for the presence of expected files after
# the mount because srv/mount do not always return
# proper status.
# $rootsrv is used in /lib/namespace because the
# root might not be served from the usual #s/boot.
#
#
#if(~ $cpunode '0' && ! ~ $fsaddr ''){
#	# wait for ethernet to come up
#	echo Atomic batteries to power
#
#	times=0
#	while(! ~ $#times 10 && ! ~ $fsaddr '' && ! eval srv -q -c -m $fsaddr $rootsrv $rootdir) {
#		echo -n '.'
#		times=($times 1)
#		sleep 5
#	}
#	echo done.	
#}
#
if(~ $cpunode '0'){
	# wait for ethernet to come up
	echo Waiting for turbines to come up to speed

	sleep 30
}
#
#if(~ $cpunode '1'){
#	fsaddr='tcp!11.' ^ $xyzip(4) ^ '!564'
#	times=0
#	while(! ~ $#times 12 && ! ~ $fsaddr '' && ! eval srv -q -c -m $fsaddr $rootsrv $rootdir) {
#		echo -n '.'
#		times=($times 1)
#		sleep 5
#	}
#	echo done.
#}

if(! test -d $rootdir/$rootspec/$cputype){
	rootdir=/boot
	rootspec=''
	rootsrv=$beetroot
}

bind -c $rootdir/$rootspec $rootdir
rootsrv='#s/'$rootsrv
echo root is on $rootdir, root is served from $rootsrv

#
# Finish the namespace setup.
#
bind -a $rootdir /
bind -b -c $rootdir/mnt /mnt
bind $rootdir/$cputype/bin /bin
bind -a $rootdir/rc/bin /bin
cd /

#
# Finish environment setup and start services.
#
if(~ $cpunode '1'){
	sysname=cpu-$treeip
}
if not {
	sysname=io-$ip(1)
}
prompt=($sysname'# ' '	') 

if(! ~ $rootdir /boot){
	ndb/cs
	ndb/dns -r
}

#ramfs so we can copy binaries in
ramfs /tmp
bind /boot/rc/bin/service /bin/service

echo starting services

if(test -d /mnt/factotum)
	aux/listen -i -q tcp
if not
	aux/listen -i -t /bin/service tcp

# do we only want to send this from one IO node?
if (~$cpunode '0') {
	echo Initiating Handshake
	echo 0x01 0x1e 0x0 0 0 0 > /dev/ras
}

# use vc0net again in future but not yet. 
#if (~$cpunode '1') rc  < /dev/vc0net > /dev/vc0net&

#if (~$cpunode '0') aux/listen1 -tv tcp!*!4444 /bin/exportfs&

# This is here so at some point we can each have
# a custom rc.local for our images. 
if(test -e /rc.local)
	. /rc.local
while(echo Hello Squidboy)
	. -i '#d/0'
